// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"permission-service/internal/app/ent/ban"
	"permission-service/internal/app/ent/email"
	"permission-service/internal/app/ent/firstlogin"
	"permission-service/internal/app/ent/loginattempts"
	"permission-service/internal/app/ent/password"
	"permission-service/internal/app/ent/permission"
	"permission-service/internal/app/ent/phone"
	"permission-service/internal/app/ent/predicate"
	"permission-service/internal/app/ent/role"
	"permission-service/internal/app/ent/rolehaspermissions"
	"permission-service/internal/app/ent/services"
	"permission-service/internal/app/ent/user"
	"permission-service/internal/app/ent/userhasroles"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBan                = "Ban"
	TypeEmail              = "Email"
	TypeFirstLogin         = "FirstLogin"
	TypeLoginAttempts      = "LoginAttempts"
	TypePassword           = "Password"
	TypePermission         = "Permission"
	TypePhone              = "Phone"
	TypeRole               = "Role"
	TypeRoleHasPermissions = "RoleHasPermissions"
	TypeServices           = "Services"
	TypeUser               = "User"
	TypeUserHasRoles       = "UserHasRoles"
)

// BanMutation represents an operation that mutates the Ban nodes in the graph.
type BanMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *int
	addcreated_by *int
	updated_by    *int
	addupdated_by *int
	deleted_by    *int
	adddeleted_by *int
	expires_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Ban, error)
	predicates    []predicate.Ban
}

var _ ent.Mutation = (*BanMutation)(nil)

// banOption allows management of the mutation configuration using functional options.
type banOption func(*BanMutation)

// newBanMutation creates new mutation for the Ban entity.
func newBanMutation(c config, op Op, opts ...banOption) *BanMutation {
	m := &BanMutation{
		config:        c,
		op:            op,
		typ:           TypeBan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanID sets the ID field of the mutation.
func withBanID(id int) banOption {
	return func(m *BanMutation) {
		var (
			err   error
			once  sync.Once
			value *Ban
		)
		m.oldValue = func(ctx context.Context) (*Ban, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ban.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBan sets the old Ban of the mutation.
func withBan(node *Ban) banOption {
	return func(m *BanMutation) {
		m.oldValue = func(context.Context) (*Ban, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ban.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ban.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ban.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ban.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *BanMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BanMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BanMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BanMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BanMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BanMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BanMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BanMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BanMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BanMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *BanMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *BanMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *BanMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *BanMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *BanMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[ban.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *BanMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[ban.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *BanMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, ban.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *BanMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BanMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BanMutation) ResetUserID() {
	m.user = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *BanMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *BanMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *BanMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *BanMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[ban.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BanMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BanMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BanMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BanMutation builder.
func (m *BanMutation) Where(ps ...predicate.Ban) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ban, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ban).
func (m *BanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, ban.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ban.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ban.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, ban.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, ban.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, ban.FieldDeletedBy)
	}
	if m.user != nil {
		fields = append(fields, ban.FieldUserID)
	}
	if m.expires_at != nil {
		fields = append(fields, ban.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ban.FieldCreatedAt:
		return m.CreatedAt()
	case ban.FieldUpdatedAt:
		return m.UpdatedAt()
	case ban.FieldDeletedAt:
		return m.DeletedAt()
	case ban.FieldCreatedBy:
		return m.CreatedBy()
	case ban.FieldUpdatedBy:
		return m.UpdatedBy()
	case ban.FieldDeletedBy:
		return m.DeletedBy()
	case ban.FieldUserID:
		return m.UserID()
	case ban.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ban.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ban.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ban.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ban.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case ban.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case ban.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case ban.FieldUserID:
		return m.OldUserID(ctx)
	case ban.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ban field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ban.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ban.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ban.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ban.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case ban.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case ban.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case ban.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case ban.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ban field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, ban.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, ban.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, ban.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ban.FieldCreatedBy:
		return m.AddedCreatedBy()
	case ban.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case ban.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ban.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case ban.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case ban.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Ban numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ban.FieldDeletedAt) {
		fields = append(fields, ban.FieldDeletedAt)
	}
	if m.FieldCleared(ban.FieldDeletedBy) {
		fields = append(fields, ban.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanMutation) ClearField(name string) error {
	switch name {
	case ban.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case ban.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Ban nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanMutation) ResetField(name string) error {
	switch name {
	case ban.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ban.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ban.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ban.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case ban.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case ban.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case ban.FieldUserID:
		m.ResetUserID()
		return nil
	case ban.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Ban field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, ban.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ban.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, ban.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanMutation) EdgeCleared(name string) bool {
	switch name {
	case ban.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanMutation) ClearEdge(name string) error {
	switch name {
	case ban.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Ban unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanMutation) ResetEdge(name string) error {
	switch name {
	case ban.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Ban edge %s", name)
}

// EmailMutation represents an operation that mutates the Email nodes in the graph.
type EmailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *int
	addcreated_by *int
	updated_by    *int
	addupdated_by *int
	deleted_by    *int
	adddeleted_by *int
	email         *string
	main          *bool
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Email, error)
	predicates    []predicate.Email
}

var _ ent.Mutation = (*EmailMutation)(nil)

// emailOption allows management of the mutation configuration using functional options.
type emailOption func(*EmailMutation)

// newEmailMutation creates new mutation for the Email entity.
func newEmailMutation(c config, op Op, opts ...emailOption) *EmailMutation {
	m := &EmailMutation{
		config:        c,
		op:            op,
		typ:           TypeEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailID sets the ID field of the mutation.
func withEmailID(id int) emailOption {
	return func(m *EmailMutation) {
		var (
			err   error
			once  sync.Once
			value *Email
		)
		m.oldValue = func(ctx context.Context) (*Email, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Email.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmail sets the old Email of the mutation.
func withEmail(node *Email) emailOption {
	return func(m *EmailMutation) {
		m.oldValue = func(context.Context) (*Email, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Email.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmailMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmailMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmailMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[email.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmailMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[email.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, email.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EmailMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EmailMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EmailMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EmailMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EmailMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EmailMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EmailMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EmailMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EmailMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EmailMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EmailMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EmailMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *EmailMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *EmailMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EmailMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[email.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EmailMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[email.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EmailMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, email.FieldDeletedBy)
}

// SetEmail sets the "email" field.
func (m *EmailMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmailMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmailMutation) ResetEmail() {
	m.email = nil
}

// SetUserID sets the "user_id" field.
func (m *EmailMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EmailMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EmailMutation) ResetUserID() {
	m.user = nil
}

// SetMain sets the "main" field.
func (m *EmailMutation) SetMain(b bool) {
	m.main = &b
}

// Main returns the value of the "main" field in the mutation.
func (m *EmailMutation) Main() (r bool, exists bool) {
	v := m.main
	if v == nil {
		return
	}
	return *v, true
}

// OldMain returns the old "main" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldMain(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMain: %w", err)
	}
	return oldValue.Main, nil
}

// ResetMain resets all changes to the "main" field.
func (m *EmailMutation) ResetMain() {
	m.main = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *EmailMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[email.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EmailMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EmailMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EmailMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EmailMutation builder.
func (m *EmailMutation) Where(ps ...predicate.Email) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Email, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Email).
func (m *EmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, email.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, email.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, email.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, email.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, email.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, email.FieldDeletedBy)
	}
	if m.email != nil {
		fields = append(fields, email.FieldEmail)
	}
	if m.user != nil {
		fields = append(fields, email.FieldUserID)
	}
	if m.main != nil {
		fields = append(fields, email.FieldMain)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case email.FieldCreatedAt:
		return m.CreatedAt()
	case email.FieldUpdatedAt:
		return m.UpdatedAt()
	case email.FieldDeletedAt:
		return m.DeletedAt()
	case email.FieldCreatedBy:
		return m.CreatedBy()
	case email.FieldUpdatedBy:
		return m.UpdatedBy()
	case email.FieldDeletedBy:
		return m.DeletedBy()
	case email.FieldEmail:
		return m.Email()
	case email.FieldUserID:
		return m.UserID()
	case email.FieldMain:
		return m.Main()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case email.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case email.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case email.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case email.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case email.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case email.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case email.FieldEmail:
		return m.OldEmail(ctx)
	case email.FieldUserID:
		return m.OldUserID(ctx)
	case email.FieldMain:
		return m.OldMain(ctx)
	}
	return nil, fmt.Errorf("unknown Email field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case email.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case email.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case email.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case email.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case email.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case email.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case email.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case email.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case email.FieldMain:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMain(v)
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, email.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, email.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, email.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case email.FieldCreatedBy:
		return m.AddedCreatedBy()
	case email.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case email.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case email.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case email.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case email.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Email numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(email.FieldDeletedAt) {
		fields = append(fields, email.FieldDeletedAt)
	}
	if m.FieldCleared(email.FieldDeletedBy) {
		fields = append(fields, email.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailMutation) ClearField(name string) error {
	switch name {
	case email.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case email.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Email nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailMutation) ResetField(name string) error {
	switch name {
	case email.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case email.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case email.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case email.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case email.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case email.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case email.FieldEmail:
		m.ResetEmail()
		return nil
	case email.FieldUserID:
		m.ResetUserID()
		return nil
	case email.FieldMain:
		m.ResetMain()
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, email.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case email.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, email.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailMutation) EdgeCleared(name string) bool {
	switch name {
	case email.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailMutation) ClearEdge(name string) error {
	switch name {
	case email.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Email unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailMutation) ResetEdge(name string) error {
	switch name {
	case email.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Email edge %s", name)
}

// FirstLoginMutation represents an operation that mutates the FirstLogin nodes in the graph.
type FirstLoginMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *int
	addcreated_by *int
	updated_by    *int
	addupdated_by *int
	deleted_by    *int
	adddeleted_by *int
	successful    *bool
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*FirstLogin, error)
	predicates    []predicate.FirstLogin
}

var _ ent.Mutation = (*FirstLoginMutation)(nil)

// firstloginOption allows management of the mutation configuration using functional options.
type firstloginOption func(*FirstLoginMutation)

// newFirstLoginMutation creates new mutation for the FirstLogin entity.
func newFirstLoginMutation(c config, op Op, opts ...firstloginOption) *FirstLoginMutation {
	m := &FirstLoginMutation{
		config:        c,
		op:            op,
		typ:           TypeFirstLogin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFirstLoginID sets the ID field of the mutation.
func withFirstLoginID(id int) firstloginOption {
	return func(m *FirstLoginMutation) {
		var (
			err   error
			once  sync.Once
			value *FirstLogin
		)
		m.oldValue = func(ctx context.Context) (*FirstLogin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FirstLogin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFirstLogin sets the old FirstLogin of the mutation.
func withFirstLogin(node *FirstLogin) firstloginOption {
	return func(m *FirstLoginMutation) {
		m.oldValue = func(context.Context) (*FirstLogin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FirstLoginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FirstLoginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FirstLoginMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FirstLoginMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FirstLogin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FirstLoginMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FirstLoginMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FirstLogin entity.
// If the FirstLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirstLoginMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FirstLoginMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FirstLoginMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FirstLoginMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FirstLogin entity.
// If the FirstLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirstLoginMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FirstLoginMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FirstLoginMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FirstLoginMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FirstLogin entity.
// If the FirstLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirstLoginMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FirstLoginMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[firstlogin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FirstLoginMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[firstlogin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FirstLoginMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, firstlogin.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FirstLoginMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FirstLoginMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FirstLogin entity.
// If the FirstLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirstLoginMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FirstLoginMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FirstLoginMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FirstLoginMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FirstLoginMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FirstLoginMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FirstLogin entity.
// If the FirstLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirstLoginMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FirstLoginMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FirstLoginMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FirstLoginMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FirstLoginMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FirstLoginMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FirstLogin entity.
// If the FirstLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirstLoginMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *FirstLoginMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FirstLoginMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FirstLoginMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[firstlogin.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FirstLoginMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[firstlogin.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FirstLoginMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, firstlogin.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *FirstLoginMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FirstLoginMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FirstLogin entity.
// If the FirstLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirstLoginMutation) OldUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FirstLoginMutation) ResetUserID() {
	m.user = nil
}

// SetSuccessful sets the "successful" field.
func (m *FirstLoginMutation) SetSuccessful(b bool) {
	m.successful = &b
}

// Successful returns the value of the "successful" field in the mutation.
func (m *FirstLoginMutation) Successful() (r bool, exists bool) {
	v := m.successful
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessful returns the old "successful" field's value of the FirstLogin entity.
// If the FirstLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirstLoginMutation) OldSuccessful(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessful is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessful requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessful: %w", err)
	}
	return oldValue.Successful, nil
}

// ResetSuccessful resets all changes to the "successful" field.
func (m *FirstLoginMutation) ResetSuccessful() {
	m.successful = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *FirstLoginMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[firstlogin.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FirstLoginMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FirstLoginMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FirstLoginMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the FirstLoginMutation builder.
func (m *FirstLoginMutation) Where(ps ...predicate.FirstLogin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FirstLoginMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FirstLoginMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FirstLogin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FirstLoginMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FirstLoginMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FirstLogin).
func (m *FirstLoginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FirstLoginMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, firstlogin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, firstlogin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, firstlogin.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, firstlogin.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, firstlogin.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, firstlogin.FieldDeletedBy)
	}
	if m.user != nil {
		fields = append(fields, firstlogin.FieldUserID)
	}
	if m.successful != nil {
		fields = append(fields, firstlogin.FieldSuccessful)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FirstLoginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case firstlogin.FieldCreatedAt:
		return m.CreatedAt()
	case firstlogin.FieldUpdatedAt:
		return m.UpdatedAt()
	case firstlogin.FieldDeletedAt:
		return m.DeletedAt()
	case firstlogin.FieldCreatedBy:
		return m.CreatedBy()
	case firstlogin.FieldUpdatedBy:
		return m.UpdatedBy()
	case firstlogin.FieldDeletedBy:
		return m.DeletedBy()
	case firstlogin.FieldUserID:
		return m.UserID()
	case firstlogin.FieldSuccessful:
		return m.Successful()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FirstLoginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case firstlogin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case firstlogin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case firstlogin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case firstlogin.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case firstlogin.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case firstlogin.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case firstlogin.FieldUserID:
		return m.OldUserID(ctx)
	case firstlogin.FieldSuccessful:
		return m.OldSuccessful(ctx)
	}
	return nil, fmt.Errorf("unknown FirstLogin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FirstLoginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case firstlogin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case firstlogin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case firstlogin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case firstlogin.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case firstlogin.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case firstlogin.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case firstlogin.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case firstlogin.FieldSuccessful:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessful(v)
		return nil
	}
	return fmt.Errorf("unknown FirstLogin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FirstLoginMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, firstlogin.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, firstlogin.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, firstlogin.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FirstLoginMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case firstlogin.FieldCreatedBy:
		return m.AddedCreatedBy()
	case firstlogin.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case firstlogin.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FirstLoginMutation) AddField(name string, value ent.Value) error {
	switch name {
	case firstlogin.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case firstlogin.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case firstlogin.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown FirstLogin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FirstLoginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(firstlogin.FieldDeletedAt) {
		fields = append(fields, firstlogin.FieldDeletedAt)
	}
	if m.FieldCleared(firstlogin.FieldDeletedBy) {
		fields = append(fields, firstlogin.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FirstLoginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FirstLoginMutation) ClearField(name string) error {
	switch name {
	case firstlogin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case firstlogin.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown FirstLogin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FirstLoginMutation) ResetField(name string) error {
	switch name {
	case firstlogin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case firstlogin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case firstlogin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case firstlogin.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case firstlogin.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case firstlogin.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case firstlogin.FieldUserID:
		m.ResetUserID()
		return nil
	case firstlogin.FieldSuccessful:
		m.ResetSuccessful()
		return nil
	}
	return fmt.Errorf("unknown FirstLogin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FirstLoginMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, firstlogin.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FirstLoginMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case firstlogin.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FirstLoginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FirstLoginMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FirstLoginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, firstlogin.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FirstLoginMutation) EdgeCleared(name string) bool {
	switch name {
	case firstlogin.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FirstLoginMutation) ClearEdge(name string) error {
	switch name {
	case firstlogin.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown FirstLogin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FirstLoginMutation) ResetEdge(name string) error {
	switch name {
	case firstlogin.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown FirstLogin edge %s", name)
}

// LoginAttemptsMutation represents an operation that mutates the LoginAttempts nodes in the graph.
type LoginAttemptsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *int
	addcreated_by *int
	updated_by    *int
	addupdated_by *int
	deleted_by    *int
	adddeleted_by *int
	successful    *bool
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*LoginAttempts, error)
	predicates    []predicate.LoginAttempts
}

var _ ent.Mutation = (*LoginAttemptsMutation)(nil)

// loginattemptsOption allows management of the mutation configuration using functional options.
type loginattemptsOption func(*LoginAttemptsMutation)

// newLoginAttemptsMutation creates new mutation for the LoginAttempts entity.
func newLoginAttemptsMutation(c config, op Op, opts ...loginattemptsOption) *LoginAttemptsMutation {
	m := &LoginAttemptsMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginAttempts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginAttemptsID sets the ID field of the mutation.
func withLoginAttemptsID(id int) loginattemptsOption {
	return func(m *LoginAttemptsMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginAttempts
		)
		m.oldValue = func(ctx context.Context) (*LoginAttempts, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginAttempts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginAttempts sets the old LoginAttempts of the mutation.
func withLoginAttempts(node *LoginAttempts) loginattemptsOption {
	return func(m *LoginAttemptsMutation) {
		m.oldValue = func(context.Context) (*LoginAttempts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginAttemptsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginAttemptsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginAttemptsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginAttemptsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginAttempts.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginAttemptsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginAttemptsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginAttempts entity.
// If the LoginAttempts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginAttemptsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoginAttemptsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoginAttemptsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoginAttempts entity.
// If the LoginAttempts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoginAttemptsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LoginAttemptsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LoginAttemptsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LoginAttempts entity.
// If the LoginAttempts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LoginAttemptsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[loginattempts.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LoginAttemptsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[loginattempts.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LoginAttemptsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, loginattempts.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *LoginAttemptsMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LoginAttemptsMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LoginAttempts entity.
// If the LoginAttempts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptsMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LoginAttemptsMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LoginAttemptsMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LoginAttemptsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LoginAttemptsMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LoginAttemptsMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LoginAttempts entity.
// If the LoginAttempts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptsMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LoginAttemptsMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LoginAttemptsMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LoginAttemptsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *LoginAttemptsMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *LoginAttemptsMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the LoginAttempts entity.
// If the LoginAttempts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptsMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *LoginAttemptsMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *LoginAttemptsMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *LoginAttemptsMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[loginattempts.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *LoginAttemptsMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[loginattempts.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *LoginAttemptsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, loginattempts.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *LoginAttemptsMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LoginAttemptsMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LoginAttempts entity.
// If the LoginAttempts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LoginAttemptsMutation) ResetUserID() {
	m.user = nil
}

// SetSuccessful sets the "successful" field.
func (m *LoginAttemptsMutation) SetSuccessful(b bool) {
	m.successful = &b
}

// Successful returns the value of the "successful" field in the mutation.
func (m *LoginAttemptsMutation) Successful() (r bool, exists bool) {
	v := m.successful
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessful returns the old "successful" field's value of the LoginAttempts entity.
// If the LoginAttempts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptsMutation) OldSuccessful(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessful is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessful requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessful: %w", err)
	}
	return oldValue.Successful, nil
}

// ResetSuccessful resets all changes to the "successful" field.
func (m *LoginAttemptsMutation) ResetSuccessful() {
	m.successful = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *LoginAttemptsMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[loginattempts.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LoginAttemptsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LoginAttemptsMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LoginAttemptsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the LoginAttemptsMutation builder.
func (m *LoginAttemptsMutation) Where(ps ...predicate.LoginAttempts) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginAttemptsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginAttemptsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginAttempts, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginAttemptsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginAttemptsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginAttempts).
func (m *LoginAttemptsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginAttemptsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, loginattempts.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loginattempts.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, loginattempts.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, loginattempts.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, loginattempts.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, loginattempts.FieldDeletedBy)
	}
	if m.user != nil {
		fields = append(fields, loginattempts.FieldUserID)
	}
	if m.successful != nil {
		fields = append(fields, loginattempts.FieldSuccessful)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginAttemptsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginattempts.FieldCreatedAt:
		return m.CreatedAt()
	case loginattempts.FieldUpdatedAt:
		return m.UpdatedAt()
	case loginattempts.FieldDeletedAt:
		return m.DeletedAt()
	case loginattempts.FieldCreatedBy:
		return m.CreatedBy()
	case loginattempts.FieldUpdatedBy:
		return m.UpdatedBy()
	case loginattempts.FieldDeletedBy:
		return m.DeletedBy()
	case loginattempts.FieldUserID:
		return m.UserID()
	case loginattempts.FieldSuccessful:
		return m.Successful()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginAttemptsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginattempts.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginattempts.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loginattempts.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case loginattempts.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case loginattempts.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case loginattempts.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case loginattempts.FieldUserID:
		return m.OldUserID(ctx)
	case loginattempts.FieldSuccessful:
		return m.OldSuccessful(ctx)
	}
	return nil, fmt.Errorf("unknown LoginAttempts field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginAttemptsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginattempts.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginattempts.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loginattempts.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case loginattempts.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case loginattempts.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case loginattempts.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case loginattempts.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case loginattempts.FieldSuccessful:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessful(v)
		return nil
	}
	return fmt.Errorf("unknown LoginAttempts field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginAttemptsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, loginattempts.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, loginattempts.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, loginattempts.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginAttemptsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loginattempts.FieldCreatedBy:
		return m.AddedCreatedBy()
	case loginattempts.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case loginattempts.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginAttemptsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loginattempts.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case loginattempts.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case loginattempts.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown LoginAttempts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginAttemptsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginattempts.FieldDeletedAt) {
		fields = append(fields, loginattempts.FieldDeletedAt)
	}
	if m.FieldCleared(loginattempts.FieldDeletedBy) {
		fields = append(fields, loginattempts.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginAttemptsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginAttemptsMutation) ClearField(name string) error {
	switch name {
	case loginattempts.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case loginattempts.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown LoginAttempts nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginAttemptsMutation) ResetField(name string) error {
	switch name {
	case loginattempts.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginattempts.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loginattempts.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case loginattempts.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case loginattempts.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case loginattempts.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case loginattempts.FieldUserID:
		m.ResetUserID()
		return nil
	case loginattempts.FieldSuccessful:
		m.ResetSuccessful()
		return nil
	}
	return fmt.Errorf("unknown LoginAttempts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginAttemptsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, loginattempts.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginAttemptsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case loginattempts.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginAttemptsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginAttemptsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginAttemptsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, loginattempts.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginAttemptsMutation) EdgeCleared(name string) bool {
	switch name {
	case loginattempts.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginAttemptsMutation) ClearEdge(name string) error {
	switch name {
	case loginattempts.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown LoginAttempts unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginAttemptsMutation) ResetEdge(name string) error {
	switch name {
	case loginattempts.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown LoginAttempts edge %s", name)
}

// PasswordMutation represents an operation that mutates the Password nodes in the graph.
type PasswordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *int
	addcreated_by *int
	updated_by    *int
	addupdated_by *int
	deleted_by    *int
	adddeleted_by *int
	password      *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Password, error)
	predicates    []predicate.Password
}

var _ ent.Mutation = (*PasswordMutation)(nil)

// passwordOption allows management of the mutation configuration using functional options.
type passwordOption func(*PasswordMutation)

// newPasswordMutation creates new mutation for the Password entity.
func newPasswordMutation(c config, op Op, opts ...passwordOption) *PasswordMutation {
	m := &PasswordMutation{
		config:        c,
		op:            op,
		typ:           TypePassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordID sets the ID field of the mutation.
func withPasswordID(id int) passwordOption {
	return func(m *PasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *Password
		)
		m.oldValue = func(ctx context.Context) (*Password, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Password.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPassword sets the old Password of the mutation.
func withPassword(node *Password) passwordOption {
	return func(m *PasswordMutation) {
		m.oldValue = func(context.Context) (*Password, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Password.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasswordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasswordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasswordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PasswordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PasswordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PasswordMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[password.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PasswordMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[password.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PasswordMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, password.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PasswordMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PasswordMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PasswordMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PasswordMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PasswordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PasswordMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PasswordMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PasswordMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PasswordMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PasswordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PasswordMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PasswordMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *PasswordMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PasswordMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PasswordMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[password.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PasswordMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[password.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PasswordMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, password.FieldDeletedBy)
}

// SetPassword sets the "password" field.
func (m *PasswordMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *PasswordMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *PasswordMutation) ResetPassword() {
	m.password = nil
}

// SetUserID sets the "user_id" field.
func (m *PasswordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasswordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasswordMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[password.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordMutation builder.
func (m *PasswordMutation) Where(ps ...predicate.Password) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Password, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Password).
func (m *PasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, password.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, password.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, password.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, password.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, password.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, password.FieldDeletedBy)
	}
	if m.password != nil {
		fields = append(fields, password.FieldPassword)
	}
	if m.user != nil {
		fields = append(fields, password.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case password.FieldCreatedAt:
		return m.CreatedAt()
	case password.FieldUpdatedAt:
		return m.UpdatedAt()
	case password.FieldDeletedAt:
		return m.DeletedAt()
	case password.FieldCreatedBy:
		return m.CreatedBy()
	case password.FieldUpdatedBy:
		return m.UpdatedBy()
	case password.FieldDeletedBy:
		return m.DeletedBy()
	case password.FieldPassword:
		return m.Password()
	case password.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case password.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case password.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case password.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case password.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case password.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case password.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case password.FieldPassword:
		return m.OldPassword(ctx)
	case password.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Password field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case password.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case password.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case password.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case password.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case password.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case password.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case password.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case password.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Password field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, password.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, password.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, password.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case password.FieldCreatedBy:
		return m.AddedCreatedBy()
	case password.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case password.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case password.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case password.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case password.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Password numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(password.FieldDeletedAt) {
		fields = append(fields, password.FieldDeletedAt)
	}
	if m.FieldCleared(password.FieldDeletedBy) {
		fields = append(fields, password.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordMutation) ClearField(name string) error {
	switch name {
	case password.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case password.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Password nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordMutation) ResetField(name string) error {
	switch name {
	case password.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case password.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case password.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case password.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case password.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case password.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case password.FieldPassword:
		m.ResetPassword()
		return nil
	case password.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Password field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, password.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case password.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, password.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordMutation) EdgeCleared(name string) bool {
	switch name {
	case password.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordMutation) ClearEdge(name string) error {
	switch name {
	case password.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Password unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordMutation) ResetEdge(name string) error {
	switch name {
	case password.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Password edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	created_by                  *int
	addcreated_by               *int
	updated_by                  *int
	addupdated_by               *int
	deleted_by                  *int
	adddeleted_by               *int
	service_id                  *int
	addservice_id               *int
	name                        *string
	description                 *string
	is_active                   *bool
	internal_name               *string
	clearedFields               map[string]struct{}
	roles                       map[int]struct{}
	removedroles                map[int]struct{}
	clearedroles                bool
	role_has_permissions        map[int]struct{}
	removedrole_has_permissions map[int]struct{}
	clearedrole_has_permissions bool
	done                        bool
	oldValue                    func(context.Context) (*Permission, error)
	predicates                  []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permission.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PermissionMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PermissionMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PermissionMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PermissionMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PermissionMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PermissionMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PermissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PermissionMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PermissionMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *PermissionMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PermissionMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PermissionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[permission.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PermissionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PermissionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, permission.FieldDeletedBy)
}

// SetServiceID sets the "service_id" field.
func (m *PermissionMutation) SetServiceID(i int) {
	m.service_id = &i
	m.addservice_id = nil
}

// ServiceID returns the value of the "service_id" field in the mutation.
func (m *PermissionMutation) ServiceID() (r int, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "service_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldServiceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// AddServiceID adds i to the "service_id" field.
func (m *PermissionMutation) AddServiceID(i int) {
	if m.addservice_id != nil {
		*m.addservice_id += i
	} else {
		m.addservice_id = &i
	}
}

// AddedServiceID returns the value that was added to the "service_id" field in this mutation.
func (m *PermissionMutation) AddedServiceID() (r int, exists bool) {
	v := m.addservice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetServiceID resets all changes to the "service_id" field.
func (m *PermissionMutation) ResetServiceID() {
	m.service_id = nil
	m.addservice_id = nil
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permission.FieldDescription)
}

// SetIsActive sets the "is_active" field.
func (m *PermissionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PermissionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PermissionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetInternalName sets the "internal_name" field.
func (m *PermissionMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *PermissionMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *PermissionMutation) ResetInternalName() {
	m.internal_name = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddRoleHasPermissionIDs adds the "role_has_permissions" edge to the RoleHasPermissions entity by ids.
func (m *PermissionMutation) AddRoleHasPermissionIDs(ids ...int) {
	if m.role_has_permissions == nil {
		m.role_has_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.role_has_permissions[ids[i]] = struct{}{}
	}
}

// ClearRoleHasPermissions clears the "role_has_permissions" edge to the RoleHasPermissions entity.
func (m *PermissionMutation) ClearRoleHasPermissions() {
	m.clearedrole_has_permissions = true
}

// RoleHasPermissionsCleared reports if the "role_has_permissions" edge to the RoleHasPermissions entity was cleared.
func (m *PermissionMutation) RoleHasPermissionsCleared() bool {
	return m.clearedrole_has_permissions
}

// RemoveRoleHasPermissionIDs removes the "role_has_permissions" edge to the RoleHasPermissions entity by IDs.
func (m *PermissionMutation) RemoveRoleHasPermissionIDs(ids ...int) {
	if m.removedrole_has_permissions == nil {
		m.removedrole_has_permissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_has_permissions, ids[i])
		m.removedrole_has_permissions[ids[i]] = struct{}{}
	}
}

// RemovedRoleHasPermissions returns the removed IDs of the "role_has_permissions" edge to the RoleHasPermissions entity.
func (m *PermissionMutation) RemovedRoleHasPermissionsIDs() (ids []int) {
	for id := range m.removedrole_has_permissions {
		ids = append(ids, id)
	}
	return
}

// RoleHasPermissionsIDs returns the "role_has_permissions" edge IDs in the mutation.
func (m *PermissionMutation) RoleHasPermissionsIDs() (ids []int) {
	for id := range m.role_has_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetRoleHasPermissions resets all changes to the "role_has_permissions" edge.
func (m *PermissionMutation) ResetRoleHasPermissions() {
	m.role_has_permissions = nil
	m.clearedrole_has_permissions = false
	m.removedrole_has_permissions = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.service_id != nil {
		fields = append(fields, permission.FieldServiceID)
	}
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	if m.is_active != nil {
		fields = append(fields, permission.FieldIsActive)
	}
	if m.internal_name != nil {
		fields = append(fields, permission.FieldInternalName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldDeletedAt:
		return m.DeletedAt()
	case permission.FieldCreatedBy:
		return m.CreatedBy()
	case permission.FieldUpdatedBy:
		return m.UpdatedBy()
	case permission.FieldDeletedBy:
		return m.DeletedBy()
	case permission.FieldServiceID:
		return m.ServiceID()
	case permission.FieldName:
		return m.Name()
	case permission.FieldDescription:
		return m.Description()
	case permission.FieldIsActive:
		return m.IsActive()
	case permission.FieldInternalName:
		return m.InternalName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case permission.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case permission.FieldServiceID:
		return m.OldServiceID(ctx)
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	case permission.FieldIsActive:
		return m.OldIsActive(ctx)
	case permission.FieldInternalName:
		return m.OldInternalName(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permission.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permission.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case permission.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case permission.FieldServiceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permission.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case permission.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.addservice_id != nil {
		fields = append(fields, permission.FieldServiceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case permission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case permission.FieldDeletedBy:
		return m.AddedDeletedBy()
	case permission.FieldServiceID:
		return m.AddedServiceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case permission.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case permission.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case permission.FieldServiceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDeletedAt) {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.FieldCleared(permission.FieldDeletedBy) {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.FieldCleared(permission.FieldDescription) {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permission.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case permission.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case permission.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case permission.FieldServiceID:
		m.ResetServiceID()
		return nil
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	case permission.FieldIsActive:
		m.ResetIsActive()
		return nil
	case permission.FieldInternalName:
		m.ResetInternalName()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	if m.role_has_permissions != nil {
		edges = append(edges, permission.EdgeRoleHasPermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeRoleHasPermissions:
		ids := make([]ent.Value, 0, len(m.role_has_permissions))
		for id := range m.role_has_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	if m.removedrole_has_permissions != nil {
		edges = append(edges, permission.EdgeRoleHasPermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeRoleHasPermissions:
		ids := make([]ent.Value, 0, len(m.removedrole_has_permissions))
		for id := range m.removedrole_has_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	if m.clearedrole_has_permissions {
		edges = append(edges, permission.EdgeRoleHasPermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	case permission.EdgeRoleHasPermissions:
		return m.clearedrole_has_permissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	case permission.EdgeRoleHasPermissions:
		m.ResetRoleHasPermissions()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// PhoneMutation represents an operation that mutates the Phone nodes in the graph.
type PhoneMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *int
	addcreated_by *int
	updated_by    *int
	addupdated_by *int
	deleted_by    *int
	adddeleted_by *int
	phone         *string
	main          *bool
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Phone, error)
	predicates    []predicate.Phone
}

var _ ent.Mutation = (*PhoneMutation)(nil)

// phoneOption allows management of the mutation configuration using functional options.
type phoneOption func(*PhoneMutation)

// newPhoneMutation creates new mutation for the Phone entity.
func newPhoneMutation(c config, op Op, opts ...phoneOption) *PhoneMutation {
	m := &PhoneMutation{
		config:        c,
		op:            op,
		typ:           TypePhone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhoneID sets the ID field of the mutation.
func withPhoneID(id int) phoneOption {
	return func(m *PhoneMutation) {
		var (
			err   error
			once  sync.Once
			value *Phone
		)
		m.oldValue = func(ctx context.Context) (*Phone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Phone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhone sets the old Phone of the mutation.
func withPhone(node *Phone) phoneOption {
	return func(m *PhoneMutation) {
		m.oldValue = func(context.Context) (*Phone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PhoneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PhoneMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Phone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PhoneMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PhoneMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PhoneMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PhoneMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PhoneMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PhoneMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PhoneMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PhoneMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PhoneMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[phone.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PhoneMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[phone.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PhoneMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, phone.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PhoneMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PhoneMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PhoneMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PhoneMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PhoneMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PhoneMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PhoneMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PhoneMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PhoneMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PhoneMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PhoneMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PhoneMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *PhoneMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PhoneMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PhoneMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[phone.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PhoneMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[phone.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PhoneMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, phone.FieldDeletedBy)
}

// SetPhone sets the "phone" field.
func (m *PhoneMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PhoneMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *PhoneMutation) ResetPhone() {
	m.phone = nil
}

// SetUserID sets the "user_id" field.
func (m *PhoneMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PhoneMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PhoneMutation) ResetUserID() {
	m.user = nil
}

// SetMain sets the "main" field.
func (m *PhoneMutation) SetMain(b bool) {
	m.main = &b
}

// Main returns the value of the "main" field in the mutation.
func (m *PhoneMutation) Main() (r bool, exists bool) {
	v := m.main
	if v == nil {
		return
	}
	return *v, true
}

// OldMain returns the old "main" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldMain(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMain: %w", err)
	}
	return oldValue.Main, nil
}

// ResetMain resets all changes to the "main" field.
func (m *PhoneMutation) ResetMain() {
	m.main = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PhoneMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[phone.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PhoneMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PhoneMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PhoneMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PhoneMutation builder.
func (m *PhoneMutation) Where(ps ...predicate.Phone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PhoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PhoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Phone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PhoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PhoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Phone).
func (m *PhoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PhoneMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, phone.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, phone.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, phone.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, phone.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, phone.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, phone.FieldDeletedBy)
	}
	if m.phone != nil {
		fields = append(fields, phone.FieldPhone)
	}
	if m.user != nil {
		fields = append(fields, phone.FieldUserID)
	}
	if m.main != nil {
		fields = append(fields, phone.FieldMain)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PhoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case phone.FieldCreatedAt:
		return m.CreatedAt()
	case phone.FieldUpdatedAt:
		return m.UpdatedAt()
	case phone.FieldDeletedAt:
		return m.DeletedAt()
	case phone.FieldCreatedBy:
		return m.CreatedBy()
	case phone.FieldUpdatedBy:
		return m.UpdatedBy()
	case phone.FieldDeletedBy:
		return m.DeletedBy()
	case phone.FieldPhone:
		return m.Phone()
	case phone.FieldUserID:
		return m.UserID()
	case phone.FieldMain:
		return m.Main()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PhoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case phone.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case phone.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case phone.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case phone.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case phone.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case phone.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case phone.FieldPhone:
		return m.OldPhone(ctx)
	case phone.FieldUserID:
		return m.OldUserID(ctx)
	case phone.FieldMain:
		return m.OldMain(ctx)
	}
	return nil, fmt.Errorf("unknown Phone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case phone.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case phone.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case phone.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case phone.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case phone.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case phone.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case phone.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case phone.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case phone.FieldMain:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMain(v)
		return nil
	}
	return fmt.Errorf("unknown Phone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PhoneMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, phone.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, phone.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, phone.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PhoneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case phone.FieldCreatedBy:
		return m.AddedCreatedBy()
	case phone.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case phone.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	case phone.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case phone.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case phone.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Phone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PhoneMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(phone.FieldDeletedAt) {
		fields = append(fields, phone.FieldDeletedAt)
	}
	if m.FieldCleared(phone.FieldDeletedBy) {
		fields = append(fields, phone.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PhoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhoneMutation) ClearField(name string) error {
	switch name {
	case phone.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case phone.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Phone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PhoneMutation) ResetField(name string) error {
	switch name {
	case phone.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case phone.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case phone.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case phone.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case phone.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case phone.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case phone.FieldPhone:
		m.ResetPhone()
		return nil
	case phone.FieldUserID:
		m.ResetUserID()
		return nil
	case phone.FieldMain:
		m.ResetMain()
		return nil
	}
	return fmt.Errorf("unknown Phone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PhoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, phone.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PhoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case phone.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PhoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PhoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PhoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, phone.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PhoneMutation) EdgeCleared(name string) bool {
	switch name {
	case phone.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PhoneMutation) ClearEdge(name string) error {
	switch name {
	case phone.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Phone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PhoneMutation) ResetEdge(name string) error {
	switch name {
	case phone.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Phone edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	created_by                  *int
	addcreated_by               *int
	updated_by                  *int
	addupdated_by               *int
	deleted_by                  *int
	adddeleted_by               *int
	name                        *string
	description                 *string
	is_active                   *bool
	clearedFields               map[string]struct{}
	permissions                 map[int]struct{}
	removedpermissions          map[int]struct{}
	clearedpermissions          bool
	users                       map[int]struct{}
	removedusers                map[int]struct{}
	clearedusers                bool
	role_has_permissions        map[int]struct{}
	removedrole_has_permissions map[int]struct{}
	clearedrole_has_permissions bool
	user_has_roles              map[int]struct{}
	removeduser_has_roles       map[int]struct{}
	cleareduser_has_roles       bool
	done                        bool
	oldValue                    func(context.Context) (*Role, error)
	predicates                  []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RoleMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RoleMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RoleMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RoleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RoleMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RoleMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RoleMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RoleMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *RoleMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *RoleMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RoleMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[role.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RoleMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RoleMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, role.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetIsActive sets the "is_active" field.
func (m *RoleMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *RoleMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *RoleMutation) ResetIsActive() {
	m.is_active = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddRoleHasPermissionIDs adds the "role_has_permissions" edge to the RoleHasPermissions entity by ids.
func (m *RoleMutation) AddRoleHasPermissionIDs(ids ...int) {
	if m.role_has_permissions == nil {
		m.role_has_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.role_has_permissions[ids[i]] = struct{}{}
	}
}

// ClearRoleHasPermissions clears the "role_has_permissions" edge to the RoleHasPermissions entity.
func (m *RoleMutation) ClearRoleHasPermissions() {
	m.clearedrole_has_permissions = true
}

// RoleHasPermissionsCleared reports if the "role_has_permissions" edge to the RoleHasPermissions entity was cleared.
func (m *RoleMutation) RoleHasPermissionsCleared() bool {
	return m.clearedrole_has_permissions
}

// RemoveRoleHasPermissionIDs removes the "role_has_permissions" edge to the RoleHasPermissions entity by IDs.
func (m *RoleMutation) RemoveRoleHasPermissionIDs(ids ...int) {
	if m.removedrole_has_permissions == nil {
		m.removedrole_has_permissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_has_permissions, ids[i])
		m.removedrole_has_permissions[ids[i]] = struct{}{}
	}
}

// RemovedRoleHasPermissions returns the removed IDs of the "role_has_permissions" edge to the RoleHasPermissions entity.
func (m *RoleMutation) RemovedRoleHasPermissionsIDs() (ids []int) {
	for id := range m.removedrole_has_permissions {
		ids = append(ids, id)
	}
	return
}

// RoleHasPermissionsIDs returns the "role_has_permissions" edge IDs in the mutation.
func (m *RoleMutation) RoleHasPermissionsIDs() (ids []int) {
	for id := range m.role_has_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetRoleHasPermissions resets all changes to the "role_has_permissions" edge.
func (m *RoleMutation) ResetRoleHasPermissions() {
	m.role_has_permissions = nil
	m.clearedrole_has_permissions = false
	m.removedrole_has_permissions = nil
}

// AddUserHasRoleIDs adds the "user_has_roles" edge to the UserHasRoles entity by ids.
func (m *RoleMutation) AddUserHasRoleIDs(ids ...int) {
	if m.user_has_roles == nil {
		m.user_has_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_has_roles[ids[i]] = struct{}{}
	}
}

// ClearUserHasRoles clears the "user_has_roles" edge to the UserHasRoles entity.
func (m *RoleMutation) ClearUserHasRoles() {
	m.cleareduser_has_roles = true
}

// UserHasRolesCleared reports if the "user_has_roles" edge to the UserHasRoles entity was cleared.
func (m *RoleMutation) UserHasRolesCleared() bool {
	return m.cleareduser_has_roles
}

// RemoveUserHasRoleIDs removes the "user_has_roles" edge to the UserHasRoles entity by IDs.
func (m *RoleMutation) RemoveUserHasRoleIDs(ids ...int) {
	if m.removeduser_has_roles == nil {
		m.removeduser_has_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_has_roles, ids[i])
		m.removeduser_has_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserHasRoles returns the removed IDs of the "user_has_roles" edge to the UserHasRoles entity.
func (m *RoleMutation) RemovedUserHasRolesIDs() (ids []int) {
	for id := range m.removeduser_has_roles {
		ids = append(ids, id)
	}
	return
}

// UserHasRolesIDs returns the "user_has_roles" edge IDs in the mutation.
func (m *RoleMutation) UserHasRolesIDs() (ids []int) {
	for id := range m.user_has_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserHasRoles resets all changes to the "user_has_roles" edge.
func (m *RoleMutation) ResetUserHasRoles() {
	m.user_has_roles = nil
	m.cleareduser_has_roles = false
	m.removeduser_has_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, role.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, role.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.is_active != nil {
		fields = append(fields, role.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldCreatedBy:
		return m.CreatedBy()
	case role.FieldUpdatedBy:
		return m.UpdatedBy()
	case role.FieldDeletedBy:
		return m.DeletedBy()
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case role.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case role.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case role.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case role.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, role.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, role.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedBy:
		return m.AddedCreatedBy()
	case role.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case role.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case role.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case role.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.FieldCleared(role.FieldDeletedBy) {
		fields = append(fields, role.FieldDeletedBy)
	}
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case role.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case role.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case role.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.role_has_permissions != nil {
		edges = append(edges, role.EdgeRoleHasPermissions)
	}
	if m.user_has_roles != nil {
		edges = append(edges, role.EdgeUserHasRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRoleHasPermissions:
		ids := make([]ent.Value, 0, len(m.role_has_permissions))
		for id := range m.role_has_permissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserHasRoles:
		ids := make([]ent.Value, 0, len(m.user_has_roles))
		for id := range m.user_has_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removedrole_has_permissions != nil {
		edges = append(edges, role.EdgeRoleHasPermissions)
	}
	if m.removeduser_has_roles != nil {
		edges = append(edges, role.EdgeUserHasRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRoleHasPermissions:
		ids := make([]ent.Value, 0, len(m.removedrole_has_permissions))
		for id := range m.removedrole_has_permissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserHasRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_has_roles))
		for id := range m.removeduser_has_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedrole_has_permissions {
		edges = append(edges, role.EdgeRoleHasPermissions)
	}
	if m.cleareduser_has_roles {
		edges = append(edges, role.EdgeUserHasRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgePermissions:
		return m.clearedpermissions
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgeRoleHasPermissions:
		return m.clearedrole_has_permissions
	case role.EdgeUserHasRoles:
		return m.cleareduser_has_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgeRoleHasPermissions:
		m.ResetRoleHasPermissions()
		return nil
	case role.EdgeUserHasRoles:
		m.ResetUserHasRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RoleHasPermissionsMutation represents an operation that mutates the RoleHasPermissions nodes in the graph.
type RoleHasPermissionsMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	created_by         *int
	addcreated_by      *int
	updated_by         *int
	addupdated_by      *int
	deleted_by         *int
	adddeleted_by      *int
	clearedFields      map[string]struct{}
	roles              *int
	clearedroles       bool
	permissions        *int
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*RoleHasPermissions, error)
	predicates         []predicate.RoleHasPermissions
}

var _ ent.Mutation = (*RoleHasPermissionsMutation)(nil)

// rolehaspermissionsOption allows management of the mutation configuration using functional options.
type rolehaspermissionsOption func(*RoleHasPermissionsMutation)

// newRoleHasPermissionsMutation creates new mutation for the RoleHasPermissions entity.
func newRoleHasPermissionsMutation(c config, op Op, opts ...rolehaspermissionsOption) *RoleHasPermissionsMutation {
	m := &RoleHasPermissionsMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleHasPermissions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleHasPermissionsID sets the ID field of the mutation.
func withRoleHasPermissionsID(id int) rolehaspermissionsOption {
	return func(m *RoleHasPermissionsMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleHasPermissions
		)
		m.oldValue = func(ctx context.Context) (*RoleHasPermissions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleHasPermissions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleHasPermissions sets the old RoleHasPermissions of the mutation.
func withRoleHasPermissions(node *RoleHasPermissions) rolehaspermissionsOption {
	return func(m *RoleHasPermissionsMutation) {
		m.oldValue = func(context.Context) (*RoleHasPermissions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleHasPermissionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleHasPermissionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleHasPermissionsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleHasPermissionsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleHasPermissions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleHasPermissionsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleHasPermissionsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoleHasPermissions entity.
// If the RoleHasPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleHasPermissionsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleHasPermissionsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleHasPermissionsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleHasPermissionsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoleHasPermissions entity.
// If the RoleHasPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleHasPermissionsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleHasPermissionsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleHasPermissionsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleHasPermissionsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RoleHasPermissions entity.
// If the RoleHasPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleHasPermissionsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleHasPermissionsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[rolehaspermissions.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleHasPermissionsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[rolehaspermissions.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleHasPermissionsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, rolehaspermissions.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleHasPermissionsMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleHasPermissionsMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RoleHasPermissions entity.
// If the RoleHasPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleHasPermissionsMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RoleHasPermissionsMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RoleHasPermissionsMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleHasPermissionsMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RoleHasPermissionsMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RoleHasPermissionsMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RoleHasPermissions entity.
// If the RoleHasPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleHasPermissionsMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RoleHasPermissionsMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RoleHasPermissionsMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RoleHasPermissionsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RoleHasPermissionsMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RoleHasPermissionsMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the RoleHasPermissions entity.
// If the RoleHasPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleHasPermissionsMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *RoleHasPermissionsMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *RoleHasPermissionsMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RoleHasPermissionsMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[rolehaspermissions.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RoleHasPermissionsMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[rolehaspermissions.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RoleHasPermissionsMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, rolehaspermissions.FieldDeletedBy)
}

// SetRoleID sets the "role_id" field.
func (m *RoleHasPermissionsMutation) SetRoleID(i int) {
	m.roles = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RoleHasPermissionsMutation) RoleID() (r int, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the RoleHasPermissions entity.
// If the RoleHasPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleHasPermissionsMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RoleHasPermissionsMutation) ResetRoleID() {
	m.roles = nil
}

// SetPermissionID sets the "permission_id" field.
func (m *RoleHasPermissionsMutation) SetPermissionID(i int) {
	m.permissions = &i
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *RoleHasPermissionsMutation) PermissionID() (r int, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the RoleHasPermissions entity.
// If the RoleHasPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleHasPermissionsMutation) OldPermissionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *RoleHasPermissionsMutation) ResetPermissionID() {
	m.permissions = nil
}

// SetRolesID sets the "roles" edge to the Role entity by id.
func (m *RoleHasPermissionsMutation) SetRolesID(id int) {
	m.roles = &id
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *RoleHasPermissionsMutation) ClearRoles() {
	m.clearedroles = true
	m.clearedFields[rolehaspermissions.FieldRoleID] = struct{}{}
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *RoleHasPermissionsMutation) RolesCleared() bool {
	return m.clearedroles
}

// RolesID returns the "roles" edge ID in the mutation.
func (m *RoleHasPermissionsMutation) RolesID() (id int, exists bool) {
	if m.roles != nil {
		return *m.roles, true
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolesID instead. It exists only for internal usage by the builders.
func (m *RoleHasPermissionsMutation) RolesIDs() (ids []int) {
	if id := m.roles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *RoleHasPermissionsMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
}

// SetPermissionsID sets the "permissions" edge to the Permission entity by id.
func (m *RoleHasPermissionsMutation) SetPermissionsID(id int) {
	m.permissions = &id
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleHasPermissionsMutation) ClearPermissions() {
	m.clearedpermissions = true
	m.clearedFields[rolehaspermissions.FieldPermissionID] = struct{}{}
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleHasPermissionsMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// PermissionsID returns the "permissions" edge ID in the mutation.
func (m *RoleHasPermissionsMutation) PermissionsID() (id int, exists bool) {
	if m.permissions != nil {
		return *m.permissions, true
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionsID instead. It exists only for internal usage by the builders.
func (m *RoleHasPermissionsMutation) PermissionsIDs() (ids []int) {
	if id := m.permissions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleHasPermissionsMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
}

// Where appends a list predicates to the RoleHasPermissionsMutation builder.
func (m *RoleHasPermissionsMutation) Where(ps ...predicate.RoleHasPermissions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleHasPermissionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleHasPermissionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleHasPermissions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleHasPermissionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleHasPermissionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleHasPermissions).
func (m *RoleHasPermissionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleHasPermissionsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, rolehaspermissions.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rolehaspermissions.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rolehaspermissions.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, rolehaspermissions.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rolehaspermissions.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, rolehaspermissions.FieldDeletedBy)
	}
	if m.roles != nil {
		fields = append(fields, rolehaspermissions.FieldRoleID)
	}
	if m.permissions != nil {
		fields = append(fields, rolehaspermissions.FieldPermissionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleHasPermissionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolehaspermissions.FieldCreatedAt:
		return m.CreatedAt()
	case rolehaspermissions.FieldUpdatedAt:
		return m.UpdatedAt()
	case rolehaspermissions.FieldDeletedAt:
		return m.DeletedAt()
	case rolehaspermissions.FieldCreatedBy:
		return m.CreatedBy()
	case rolehaspermissions.FieldUpdatedBy:
		return m.UpdatedBy()
	case rolehaspermissions.FieldDeletedBy:
		return m.DeletedBy()
	case rolehaspermissions.FieldRoleID:
		return m.RoleID()
	case rolehaspermissions.FieldPermissionID:
		return m.PermissionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleHasPermissionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolehaspermissions.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rolehaspermissions.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rolehaspermissions.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rolehaspermissions.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rolehaspermissions.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rolehaspermissions.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case rolehaspermissions.FieldRoleID:
		return m.OldRoleID(ctx)
	case rolehaspermissions.FieldPermissionID:
		return m.OldPermissionID(ctx)
	}
	return nil, fmt.Errorf("unknown RoleHasPermissions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleHasPermissionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolehaspermissions.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rolehaspermissions.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rolehaspermissions.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rolehaspermissions.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rolehaspermissions.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rolehaspermissions.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case rolehaspermissions.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case rolehaspermissions.FieldPermissionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	}
	return fmt.Errorf("unknown RoleHasPermissions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleHasPermissionsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, rolehaspermissions.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, rolehaspermissions.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, rolehaspermissions.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleHasPermissionsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rolehaspermissions.FieldCreatedBy:
		return m.AddedCreatedBy()
	case rolehaspermissions.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case rolehaspermissions.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleHasPermissionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rolehaspermissions.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case rolehaspermissions.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case rolehaspermissions.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown RoleHasPermissions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleHasPermissionsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rolehaspermissions.FieldDeletedAt) {
		fields = append(fields, rolehaspermissions.FieldDeletedAt)
	}
	if m.FieldCleared(rolehaspermissions.FieldDeletedBy) {
		fields = append(fields, rolehaspermissions.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleHasPermissionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleHasPermissionsMutation) ClearField(name string) error {
	switch name {
	case rolehaspermissions.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case rolehaspermissions.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown RoleHasPermissions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleHasPermissionsMutation) ResetField(name string) error {
	switch name {
	case rolehaspermissions.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rolehaspermissions.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rolehaspermissions.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rolehaspermissions.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rolehaspermissions.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rolehaspermissions.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case rolehaspermissions.FieldRoleID:
		m.ResetRoleID()
		return nil
	case rolehaspermissions.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	}
	return fmt.Errorf("unknown RoleHasPermissions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleHasPermissionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.roles != nil {
		edges = append(edges, rolehaspermissions.EdgeRoles)
	}
	if m.permissions != nil {
		edges = append(edges, rolehaspermissions.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleHasPermissionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolehaspermissions.EdgeRoles:
		if id := m.roles; id != nil {
			return []ent.Value{*id}
		}
	case rolehaspermissions.EdgePermissions:
		if id := m.permissions; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleHasPermissionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleHasPermissionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleHasPermissionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroles {
		edges = append(edges, rolehaspermissions.EdgeRoles)
	}
	if m.clearedpermissions {
		edges = append(edges, rolehaspermissions.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleHasPermissionsMutation) EdgeCleared(name string) bool {
	switch name {
	case rolehaspermissions.EdgeRoles:
		return m.clearedroles
	case rolehaspermissions.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleHasPermissionsMutation) ClearEdge(name string) error {
	switch name {
	case rolehaspermissions.EdgeRoles:
		m.ClearRoles()
		return nil
	case rolehaspermissions.EdgePermissions:
		m.ClearPermissions()
		return nil
	}
	return fmt.Errorf("unknown RoleHasPermissions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleHasPermissionsMutation) ResetEdge(name string) error {
	switch name {
	case rolehaspermissions.EdgeRoles:
		m.ResetRoles()
		return nil
	case rolehaspermissions.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown RoleHasPermissions edge %s", name)
}

// ServicesMutation represents an operation that mutates the Services nodes in the graph.
type ServicesMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	created_by        *int
	addcreated_by     *int
	updated_by        *int
	addupdated_by     *int
	deleted_by        *int
	adddeleted_by     *int
	name              *string
	clearedFields     map[string]struct{}
	permission        map[int]struct{}
	removedpermission map[int]struct{}
	clearedpermission bool
	done              bool
	oldValue          func(context.Context) (*Services, error)
	predicates        []predicate.Services
}

var _ ent.Mutation = (*ServicesMutation)(nil)

// servicesOption allows management of the mutation configuration using functional options.
type servicesOption func(*ServicesMutation)

// newServicesMutation creates new mutation for the Services entity.
func newServicesMutation(c config, op Op, opts ...servicesOption) *ServicesMutation {
	m := &ServicesMutation{
		config:        c,
		op:            op,
		typ:           TypeServices,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServicesID sets the ID field of the mutation.
func withServicesID(id int) servicesOption {
	return func(m *ServicesMutation) {
		var (
			err   error
			once  sync.Once
			value *Services
		)
		m.oldValue = func(ctx context.Context) (*Services, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Services.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServices sets the old Services of the mutation.
func withServices(node *Services) servicesOption {
	return func(m *ServicesMutation) {
		m.oldValue = func(context.Context) (*Services, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServicesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServicesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServicesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServicesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Services.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServicesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServicesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServicesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServicesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServicesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServicesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ServicesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ServicesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ServicesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[services.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ServicesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[services.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ServicesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, services.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ServicesMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ServicesMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ServicesMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ServicesMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ServicesMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ServicesMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ServicesMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ServicesMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ServicesMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ServicesMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ServicesMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ServicesMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *ServicesMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *ServicesMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ServicesMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[services.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ServicesMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[services.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ServicesMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, services.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *ServicesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServicesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServicesMutation) ResetName() {
	m.name = nil
}

// AddPermissionIDs adds the "permission" edge to the Permission entity by ids.
func (m *ServicesMutation) AddPermissionIDs(ids ...int) {
	if m.permission == nil {
		m.permission = make(map[int]struct{})
	}
	for i := range ids {
		m.permission[ids[i]] = struct{}{}
	}
}

// ClearPermission clears the "permission" edge to the Permission entity.
func (m *ServicesMutation) ClearPermission() {
	m.clearedpermission = true
}

// PermissionCleared reports if the "permission" edge to the Permission entity was cleared.
func (m *ServicesMutation) PermissionCleared() bool {
	return m.clearedpermission
}

// RemovePermissionIDs removes the "permission" edge to the Permission entity by IDs.
func (m *ServicesMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermission == nil {
		m.removedpermission = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permission, ids[i])
		m.removedpermission[ids[i]] = struct{}{}
	}
}

// RemovedPermission returns the removed IDs of the "permission" edge to the Permission entity.
func (m *ServicesMutation) RemovedPermissionIDs() (ids []int) {
	for id := range m.removedpermission {
		ids = append(ids, id)
	}
	return
}

// PermissionIDs returns the "permission" edge IDs in the mutation.
func (m *ServicesMutation) PermissionIDs() (ids []int) {
	for id := range m.permission {
		ids = append(ids, id)
	}
	return
}

// ResetPermission resets all changes to the "permission" edge.
func (m *ServicesMutation) ResetPermission() {
	m.permission = nil
	m.clearedpermission = false
	m.removedpermission = nil
}

// Where appends a list predicates to the ServicesMutation builder.
func (m *ServicesMutation) Where(ps ...predicate.Services) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServicesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServicesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Services, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServicesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServicesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Services).
func (m *ServicesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServicesMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, services.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, services.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, services.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, services.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, services.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, services.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, services.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServicesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case services.FieldCreatedAt:
		return m.CreatedAt()
	case services.FieldUpdatedAt:
		return m.UpdatedAt()
	case services.FieldDeletedAt:
		return m.DeletedAt()
	case services.FieldCreatedBy:
		return m.CreatedBy()
	case services.FieldUpdatedBy:
		return m.UpdatedBy()
	case services.FieldDeletedBy:
		return m.DeletedBy()
	case services.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServicesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case services.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case services.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case services.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case services.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case services.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case services.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case services.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Services field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServicesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case services.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case services.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case services.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case services.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case services.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case services.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case services.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Services field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServicesMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, services.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, services.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, services.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServicesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case services.FieldCreatedBy:
		return m.AddedCreatedBy()
	case services.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case services.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServicesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case services.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case services.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case services.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Services numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServicesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(services.FieldDeletedAt) {
		fields = append(fields, services.FieldDeletedAt)
	}
	if m.FieldCleared(services.FieldDeletedBy) {
		fields = append(fields, services.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServicesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServicesMutation) ClearField(name string) error {
	switch name {
	case services.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case services.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Services nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServicesMutation) ResetField(name string) error {
	switch name {
	case services.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case services.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case services.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case services.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case services.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case services.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case services.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Services field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServicesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.permission != nil {
		edges = append(edges, services.EdgePermission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServicesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case services.EdgePermission:
		ids := make([]ent.Value, 0, len(m.permission))
		for id := range m.permission {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServicesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpermission != nil {
		edges = append(edges, services.EdgePermission)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServicesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case services.EdgePermission:
		ids := make([]ent.Value, 0, len(m.removedpermission))
		for id := range m.removedpermission {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServicesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpermission {
		edges = append(edges, services.EdgePermission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServicesMutation) EdgeCleared(name string) bool {
	switch name {
	case services.EdgePermission:
		return m.clearedpermission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServicesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Services unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServicesMutation) ResetEdge(name string) error {
	switch name {
	case services.EdgePermission:
		m.ResetPermission()
		return nil
	}
	return fmt.Errorf("unknown Services edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	created_by            *int
	addcreated_by         *int
	updated_by            *int
	addupdated_by         *int
	deleted_by            *int
	adddeleted_by         *int
	name                  *string
	_Surname              *string
	clearedFields         map[string]struct{}
	emails                map[int]struct{}
	removedemails         map[int]struct{}
	clearedemails         bool
	passwords             map[int]struct{}
	removedpasswords      map[int]struct{}
	clearedpasswords      bool
	phones                map[int]struct{}
	removedphones         map[int]struct{}
	clearedphones         bool
	ban                   map[int]struct{}
	removedban            map[int]struct{}
	clearedban            bool
	first_login           map[int]struct{}
	removedfirst_login    map[int]struct{}
	clearedfirst_login    bool
	login_attempts        map[int]struct{}
	removedlogin_attempts map[int]struct{}
	clearedlogin_attempts bool
	roles                 map[int]struct{}
	removedroles          map[int]struct{}
	clearedroles          bool
	user_has_roles        map[int]struct{}
	removeduser_has_roles map[int]struct{}
	cleareduser_has_roles bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[user.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, user.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetSurname sets the "Surname" field.
func (m *UserMutation) SetSurname(s string) {
	m._Surname = &s
}

// Surname returns the value of the "Surname" field in the mutation.
func (m *UserMutation) Surname() (r string, exists bool) {
	v := m._Surname
	if v == nil {
		return
	}
	return *v, true
}

// OldSurname returns the old "Surname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurname: %w", err)
	}
	return oldValue.Surname, nil
}

// ResetSurname resets all changes to the "Surname" field.
func (m *UserMutation) ResetSurname() {
	m._Surname = nil
}

// AddEmailIDs adds the "emails" edge to the Email entity by ids.
func (m *UserMutation) AddEmailIDs(ids ...int) {
	if m.emails == nil {
		m.emails = make(map[int]struct{})
	}
	for i := range ids {
		m.emails[ids[i]] = struct{}{}
	}
}

// ClearEmails clears the "emails" edge to the Email entity.
func (m *UserMutation) ClearEmails() {
	m.clearedemails = true
}

// EmailsCleared reports if the "emails" edge to the Email entity was cleared.
func (m *UserMutation) EmailsCleared() bool {
	return m.clearedemails
}

// RemoveEmailIDs removes the "emails" edge to the Email entity by IDs.
func (m *UserMutation) RemoveEmailIDs(ids ...int) {
	if m.removedemails == nil {
		m.removedemails = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.emails, ids[i])
		m.removedemails[ids[i]] = struct{}{}
	}
}

// RemovedEmails returns the removed IDs of the "emails" edge to the Email entity.
func (m *UserMutation) RemovedEmailsIDs() (ids []int) {
	for id := range m.removedemails {
		ids = append(ids, id)
	}
	return
}

// EmailsIDs returns the "emails" edge IDs in the mutation.
func (m *UserMutation) EmailsIDs() (ids []int) {
	for id := range m.emails {
		ids = append(ids, id)
	}
	return
}

// ResetEmails resets all changes to the "emails" edge.
func (m *UserMutation) ResetEmails() {
	m.emails = nil
	m.clearedemails = false
	m.removedemails = nil
}

// AddPasswordIDs adds the "passwords" edge to the Password entity by ids.
func (m *UserMutation) AddPasswordIDs(ids ...int) {
	if m.passwords == nil {
		m.passwords = make(map[int]struct{})
	}
	for i := range ids {
		m.passwords[ids[i]] = struct{}{}
	}
}

// ClearPasswords clears the "passwords" edge to the Password entity.
func (m *UserMutation) ClearPasswords() {
	m.clearedpasswords = true
}

// PasswordsCleared reports if the "passwords" edge to the Password entity was cleared.
func (m *UserMutation) PasswordsCleared() bool {
	return m.clearedpasswords
}

// RemovePasswordIDs removes the "passwords" edge to the Password entity by IDs.
func (m *UserMutation) RemovePasswordIDs(ids ...int) {
	if m.removedpasswords == nil {
		m.removedpasswords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.passwords, ids[i])
		m.removedpasswords[ids[i]] = struct{}{}
	}
}

// RemovedPasswords returns the removed IDs of the "passwords" edge to the Password entity.
func (m *UserMutation) RemovedPasswordsIDs() (ids []int) {
	for id := range m.removedpasswords {
		ids = append(ids, id)
	}
	return
}

// PasswordsIDs returns the "passwords" edge IDs in the mutation.
func (m *UserMutation) PasswordsIDs() (ids []int) {
	for id := range m.passwords {
		ids = append(ids, id)
	}
	return
}

// ResetPasswords resets all changes to the "passwords" edge.
func (m *UserMutation) ResetPasswords() {
	m.passwords = nil
	m.clearedpasswords = false
	m.removedpasswords = nil
}

// AddPhoneIDs adds the "phones" edge to the Phone entity by ids.
func (m *UserMutation) AddPhoneIDs(ids ...int) {
	if m.phones == nil {
		m.phones = make(map[int]struct{})
	}
	for i := range ids {
		m.phones[ids[i]] = struct{}{}
	}
}

// ClearPhones clears the "phones" edge to the Phone entity.
func (m *UserMutation) ClearPhones() {
	m.clearedphones = true
}

// PhonesCleared reports if the "phones" edge to the Phone entity was cleared.
func (m *UserMutation) PhonesCleared() bool {
	return m.clearedphones
}

// RemovePhoneIDs removes the "phones" edge to the Phone entity by IDs.
func (m *UserMutation) RemovePhoneIDs(ids ...int) {
	if m.removedphones == nil {
		m.removedphones = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.phones, ids[i])
		m.removedphones[ids[i]] = struct{}{}
	}
}

// RemovedPhones returns the removed IDs of the "phones" edge to the Phone entity.
func (m *UserMutation) RemovedPhonesIDs() (ids []int) {
	for id := range m.removedphones {
		ids = append(ids, id)
	}
	return
}

// PhonesIDs returns the "phones" edge IDs in the mutation.
func (m *UserMutation) PhonesIDs() (ids []int) {
	for id := range m.phones {
		ids = append(ids, id)
	}
	return
}

// ResetPhones resets all changes to the "phones" edge.
func (m *UserMutation) ResetPhones() {
	m.phones = nil
	m.clearedphones = false
	m.removedphones = nil
}

// AddBanIDs adds the "ban" edge to the Ban entity by ids.
func (m *UserMutation) AddBanIDs(ids ...int) {
	if m.ban == nil {
		m.ban = make(map[int]struct{})
	}
	for i := range ids {
		m.ban[ids[i]] = struct{}{}
	}
}

// ClearBan clears the "ban" edge to the Ban entity.
func (m *UserMutation) ClearBan() {
	m.clearedban = true
}

// BanCleared reports if the "ban" edge to the Ban entity was cleared.
func (m *UserMutation) BanCleared() bool {
	return m.clearedban
}

// RemoveBanIDs removes the "ban" edge to the Ban entity by IDs.
func (m *UserMutation) RemoveBanIDs(ids ...int) {
	if m.removedban == nil {
		m.removedban = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ban, ids[i])
		m.removedban[ids[i]] = struct{}{}
	}
}

// RemovedBan returns the removed IDs of the "ban" edge to the Ban entity.
func (m *UserMutation) RemovedBanIDs() (ids []int) {
	for id := range m.removedban {
		ids = append(ids, id)
	}
	return
}

// BanIDs returns the "ban" edge IDs in the mutation.
func (m *UserMutation) BanIDs() (ids []int) {
	for id := range m.ban {
		ids = append(ids, id)
	}
	return
}

// ResetBan resets all changes to the "ban" edge.
func (m *UserMutation) ResetBan() {
	m.ban = nil
	m.clearedban = false
	m.removedban = nil
}

// AddFirstLoginIDs adds the "first_login" edge to the FirstLogin entity by ids.
func (m *UserMutation) AddFirstLoginIDs(ids ...int) {
	if m.first_login == nil {
		m.first_login = make(map[int]struct{})
	}
	for i := range ids {
		m.first_login[ids[i]] = struct{}{}
	}
}

// ClearFirstLogin clears the "first_login" edge to the FirstLogin entity.
func (m *UserMutation) ClearFirstLogin() {
	m.clearedfirst_login = true
}

// FirstLoginCleared reports if the "first_login" edge to the FirstLogin entity was cleared.
func (m *UserMutation) FirstLoginCleared() bool {
	return m.clearedfirst_login
}

// RemoveFirstLoginIDs removes the "first_login" edge to the FirstLogin entity by IDs.
func (m *UserMutation) RemoveFirstLoginIDs(ids ...int) {
	if m.removedfirst_login == nil {
		m.removedfirst_login = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.first_login, ids[i])
		m.removedfirst_login[ids[i]] = struct{}{}
	}
}

// RemovedFirstLogin returns the removed IDs of the "first_login" edge to the FirstLogin entity.
func (m *UserMutation) RemovedFirstLoginIDs() (ids []int) {
	for id := range m.removedfirst_login {
		ids = append(ids, id)
	}
	return
}

// FirstLoginIDs returns the "first_login" edge IDs in the mutation.
func (m *UserMutation) FirstLoginIDs() (ids []int) {
	for id := range m.first_login {
		ids = append(ids, id)
	}
	return
}

// ResetFirstLogin resets all changes to the "first_login" edge.
func (m *UserMutation) ResetFirstLogin() {
	m.first_login = nil
	m.clearedfirst_login = false
	m.removedfirst_login = nil
}

// AddLoginAttemptIDs adds the "login_attempts" edge to the LoginAttempts entity by ids.
func (m *UserMutation) AddLoginAttemptIDs(ids ...int) {
	if m.login_attempts == nil {
		m.login_attempts = make(map[int]struct{})
	}
	for i := range ids {
		m.login_attempts[ids[i]] = struct{}{}
	}
}

// ClearLoginAttempts clears the "login_attempts" edge to the LoginAttempts entity.
func (m *UserMutation) ClearLoginAttempts() {
	m.clearedlogin_attempts = true
}

// LoginAttemptsCleared reports if the "login_attempts" edge to the LoginAttempts entity was cleared.
func (m *UserMutation) LoginAttemptsCleared() bool {
	return m.clearedlogin_attempts
}

// RemoveLoginAttemptIDs removes the "login_attempts" edge to the LoginAttempts entity by IDs.
func (m *UserMutation) RemoveLoginAttemptIDs(ids ...int) {
	if m.removedlogin_attempts == nil {
		m.removedlogin_attempts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.login_attempts, ids[i])
		m.removedlogin_attempts[ids[i]] = struct{}{}
	}
}

// RemovedLoginAttempts returns the removed IDs of the "login_attempts" edge to the LoginAttempts entity.
func (m *UserMutation) RemovedLoginAttemptsIDs() (ids []int) {
	for id := range m.removedlogin_attempts {
		ids = append(ids, id)
	}
	return
}

// LoginAttemptsIDs returns the "login_attempts" edge IDs in the mutation.
func (m *UserMutation) LoginAttemptsIDs() (ids []int) {
	for id := range m.login_attempts {
		ids = append(ids, id)
	}
	return
}

// ResetLoginAttempts resets all changes to the "login_attempts" edge.
func (m *UserMutation) ResetLoginAttempts() {
	m.login_attempts = nil
	m.clearedlogin_attempts = false
	m.removedlogin_attempts = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddUserHasRoleIDs adds the "user_has_roles" edge to the UserHasRoles entity by ids.
func (m *UserMutation) AddUserHasRoleIDs(ids ...int) {
	if m.user_has_roles == nil {
		m.user_has_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_has_roles[ids[i]] = struct{}{}
	}
}

// ClearUserHasRoles clears the "user_has_roles" edge to the UserHasRoles entity.
func (m *UserMutation) ClearUserHasRoles() {
	m.cleareduser_has_roles = true
}

// UserHasRolesCleared reports if the "user_has_roles" edge to the UserHasRoles entity was cleared.
func (m *UserMutation) UserHasRolesCleared() bool {
	return m.cleareduser_has_roles
}

// RemoveUserHasRoleIDs removes the "user_has_roles" edge to the UserHasRoles entity by IDs.
func (m *UserMutation) RemoveUserHasRoleIDs(ids ...int) {
	if m.removeduser_has_roles == nil {
		m.removeduser_has_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_has_roles, ids[i])
		m.removeduser_has_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserHasRoles returns the removed IDs of the "user_has_roles" edge to the UserHasRoles entity.
func (m *UserMutation) RemovedUserHasRolesIDs() (ids []int) {
	for id := range m.removeduser_has_roles {
		ids = append(ids, id)
	}
	return
}

// UserHasRolesIDs returns the "user_has_roles" edge IDs in the mutation.
func (m *UserMutation) UserHasRolesIDs() (ids []int) {
	for id := range m.user_has_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserHasRoles resets all changes to the "user_has_roles" edge.
func (m *UserMutation) ResetUserHasRoles() {
	m.user_has_roles = nil
	m.cleareduser_has_roles = false
	m.removeduser_has_roles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._Surname != nil {
		fields = append(fields, user.FieldSurname)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	case user.FieldName:
		return m.Name()
	case user.FieldSurname:
		return m.Surname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldSurname:
		return m.OldSurname(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldSurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurname(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case user.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldDeletedBy) {
		fields = append(fields, user.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldSurname:
		m.ResetSurname()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.emails != nil {
		edges = append(edges, user.EdgeEmails)
	}
	if m.passwords != nil {
		edges = append(edges, user.EdgePasswords)
	}
	if m.phones != nil {
		edges = append(edges, user.EdgePhones)
	}
	if m.ban != nil {
		edges = append(edges, user.EdgeBan)
	}
	if m.first_login != nil {
		edges = append(edges, user.EdgeFirstLogin)
	}
	if m.login_attempts != nil {
		edges = append(edges, user.EdgeLoginAttempts)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.user_has_roles != nil {
		edges = append(edges, user.EdgeUserHasRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.emails))
		for id := range m.emails {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.passwords))
		for id := range m.passwords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePhones:
		ids := make([]ent.Value, 0, len(m.phones))
		for id := range m.phones {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBan:
		ids := make([]ent.Value, 0, len(m.ban))
		for id := range m.ban {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFirstLogin:
		ids := make([]ent.Value, 0, len(m.first_login))
		for id := range m.first_login {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginAttempts:
		ids := make([]ent.Value, 0, len(m.login_attempts))
		for id := range m.login_attempts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHasRoles:
		ids := make([]ent.Value, 0, len(m.user_has_roles))
		for id := range m.user_has_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedemails != nil {
		edges = append(edges, user.EdgeEmails)
	}
	if m.removedpasswords != nil {
		edges = append(edges, user.EdgePasswords)
	}
	if m.removedphones != nil {
		edges = append(edges, user.EdgePhones)
	}
	if m.removedban != nil {
		edges = append(edges, user.EdgeBan)
	}
	if m.removedfirst_login != nil {
		edges = append(edges, user.EdgeFirstLogin)
	}
	if m.removedlogin_attempts != nil {
		edges = append(edges, user.EdgeLoginAttempts)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removeduser_has_roles != nil {
		edges = append(edges, user.EdgeUserHasRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.removedemails))
		for id := range m.removedemails {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.removedpasswords))
		for id := range m.removedpasswords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePhones:
		ids := make([]ent.Value, 0, len(m.removedphones))
		for id := range m.removedphones {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBan:
		ids := make([]ent.Value, 0, len(m.removedban))
		for id := range m.removedban {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFirstLogin:
		ids := make([]ent.Value, 0, len(m.removedfirst_login))
		for id := range m.removedfirst_login {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginAttempts:
		ids := make([]ent.Value, 0, len(m.removedlogin_attempts))
		for id := range m.removedlogin_attempts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHasRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_has_roles))
		for id := range m.removeduser_has_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedemails {
		edges = append(edges, user.EdgeEmails)
	}
	if m.clearedpasswords {
		edges = append(edges, user.EdgePasswords)
	}
	if m.clearedphones {
		edges = append(edges, user.EdgePhones)
	}
	if m.clearedban {
		edges = append(edges, user.EdgeBan)
	}
	if m.clearedfirst_login {
		edges = append(edges, user.EdgeFirstLogin)
	}
	if m.clearedlogin_attempts {
		edges = append(edges, user.EdgeLoginAttempts)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.cleareduser_has_roles {
		edges = append(edges, user.EdgeUserHasRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeEmails:
		return m.clearedemails
	case user.EdgePasswords:
		return m.clearedpasswords
	case user.EdgePhones:
		return m.clearedphones
	case user.EdgeBan:
		return m.clearedban
	case user.EdgeFirstLogin:
		return m.clearedfirst_login
	case user.EdgeLoginAttempts:
		return m.clearedlogin_attempts
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeUserHasRoles:
		return m.cleareduser_has_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeEmails:
		m.ResetEmails()
		return nil
	case user.EdgePasswords:
		m.ResetPasswords()
		return nil
	case user.EdgePhones:
		m.ResetPhones()
		return nil
	case user.EdgeBan:
		m.ResetBan()
		return nil
	case user.EdgeFirstLogin:
		m.ResetFirstLogin()
		return nil
	case user.EdgeLoginAttempts:
		m.ResetLoginAttempts()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeUserHasRoles:
		m.ResetUserHasRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserHasRolesMutation represents an operation that mutates the UserHasRoles nodes in the graph.
type UserHasRolesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *int
	addcreated_by *int
	updated_by    *int
	addupdated_by *int
	deleted_by    *int
	adddeleted_by *int
	clearedFields map[string]struct{}
	users         *int
	clearedusers  bool
	roles         *int
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*UserHasRoles, error)
	predicates    []predicate.UserHasRoles
}

var _ ent.Mutation = (*UserHasRolesMutation)(nil)

// userhasrolesOption allows management of the mutation configuration using functional options.
type userhasrolesOption func(*UserHasRolesMutation)

// newUserHasRolesMutation creates new mutation for the UserHasRoles entity.
func newUserHasRolesMutation(c config, op Op, opts ...userhasrolesOption) *UserHasRolesMutation {
	m := &UserHasRolesMutation{
		config:        c,
		op:            op,
		typ:           TypeUserHasRoles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserHasRolesID sets the ID field of the mutation.
func withUserHasRolesID(id int) userhasrolesOption {
	return func(m *UserHasRolesMutation) {
		var (
			err   error
			once  sync.Once
			value *UserHasRoles
		)
		m.oldValue = func(ctx context.Context) (*UserHasRoles, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserHasRoles.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserHasRoles sets the old UserHasRoles of the mutation.
func withUserHasRoles(node *UserHasRoles) userhasrolesOption {
	return func(m *UserHasRolesMutation) {
		m.oldValue = func(context.Context) (*UserHasRoles, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserHasRolesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserHasRolesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserHasRolesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserHasRolesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserHasRoles.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserHasRolesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserHasRolesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserHasRoles entity.
// If the UserHasRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHasRolesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserHasRolesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserHasRolesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserHasRolesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserHasRoles entity.
// If the UserHasRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHasRolesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserHasRolesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserHasRolesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserHasRolesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserHasRoles entity.
// If the UserHasRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHasRolesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserHasRolesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userhasroles.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserHasRolesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userhasroles.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserHasRolesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userhasroles.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserHasRolesMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserHasRolesMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserHasRoles entity.
// If the UserHasRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHasRolesMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserHasRolesMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserHasRolesMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserHasRolesMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserHasRolesMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserHasRolesMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserHasRoles entity.
// If the UserHasRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHasRolesMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserHasRolesMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserHasRolesMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserHasRolesMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserHasRolesMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserHasRolesMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserHasRoles entity.
// If the UserHasRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHasRolesMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserHasRolesMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserHasRolesMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserHasRolesMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[userhasroles.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserHasRolesMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[userhasroles.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserHasRolesMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, userhasroles.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *UserHasRolesMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserHasRolesMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserHasRoles entity.
// If the UserHasRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHasRolesMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserHasRolesMutation) ResetUserID() {
	m.users = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserHasRolesMutation) SetRoleID(i int) {
	m.roles = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserHasRolesMutation) RoleID() (r int, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserHasRoles entity.
// If the UserHasRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHasRolesMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserHasRolesMutation) ResetRoleID() {
	m.roles = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *UserHasRolesMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UserHasRolesMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[userhasroles.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UserHasRolesMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *UserHasRolesMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *UserHasRolesMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserHasRolesMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetRolesID sets the "roles" edge to the Role entity by id.
func (m *UserHasRolesMutation) SetRolesID(id int) {
	m.roles = &id
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserHasRolesMutation) ClearRoles() {
	m.clearedroles = true
	m.clearedFields[userhasroles.FieldRoleID] = struct{}{}
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserHasRolesMutation) RolesCleared() bool {
	return m.clearedroles
}

// RolesID returns the "roles" edge ID in the mutation.
func (m *UserHasRolesMutation) RolesID() (id int, exists bool) {
	if m.roles != nil {
		return *m.roles, true
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolesID instead. It exists only for internal usage by the builders.
func (m *UserHasRolesMutation) RolesIDs() (ids []int) {
	if id := m.roles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserHasRolesMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
}

// Where appends a list predicates to the UserHasRolesMutation builder.
func (m *UserHasRolesMutation) Where(ps ...predicate.UserHasRoles) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserHasRolesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserHasRolesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserHasRoles, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserHasRolesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserHasRolesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserHasRoles).
func (m *UserHasRolesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserHasRolesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, userhasroles.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userhasroles.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userhasroles.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userhasroles.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userhasroles.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, userhasroles.FieldDeletedBy)
	}
	if m.users != nil {
		fields = append(fields, userhasroles.FieldUserID)
	}
	if m.roles != nil {
		fields = append(fields, userhasroles.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserHasRolesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userhasroles.FieldCreatedAt:
		return m.CreatedAt()
	case userhasroles.FieldUpdatedAt:
		return m.UpdatedAt()
	case userhasroles.FieldDeletedAt:
		return m.DeletedAt()
	case userhasroles.FieldCreatedBy:
		return m.CreatedBy()
	case userhasroles.FieldUpdatedBy:
		return m.UpdatedBy()
	case userhasroles.FieldDeletedBy:
		return m.DeletedBy()
	case userhasroles.FieldUserID:
		return m.UserID()
	case userhasroles.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserHasRolesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userhasroles.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userhasroles.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userhasroles.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userhasroles.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userhasroles.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userhasroles.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userhasroles.FieldUserID:
		return m.OldUserID(ctx)
	case userhasroles.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown UserHasRoles field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHasRolesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userhasroles.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userhasroles.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userhasroles.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userhasroles.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userhasroles.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userhasroles.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userhasroles.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userhasroles.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown UserHasRoles field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserHasRolesMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userhasroles.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userhasroles.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userhasroles.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserHasRolesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userhasroles.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userhasroles.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userhasroles.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHasRolesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userhasroles.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userhasroles.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userhasroles.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserHasRoles numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserHasRolesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userhasroles.FieldDeletedAt) {
		fields = append(fields, userhasroles.FieldDeletedAt)
	}
	if m.FieldCleared(userhasroles.FieldDeletedBy) {
		fields = append(fields, userhasroles.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserHasRolesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserHasRolesMutation) ClearField(name string) error {
	switch name {
	case userhasroles.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userhasroles.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown UserHasRoles nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserHasRolesMutation) ResetField(name string) error {
	switch name {
	case userhasroles.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userhasroles.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userhasroles.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userhasroles.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userhasroles.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userhasroles.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userhasroles.FieldUserID:
		m.ResetUserID()
		return nil
	case userhasroles.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown UserHasRoles field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserHasRolesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, userhasroles.EdgeUsers)
	}
	if m.roles != nil {
		edges = append(edges, userhasroles.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserHasRolesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userhasroles.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case userhasroles.EdgeRoles:
		if id := m.roles; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserHasRolesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserHasRolesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserHasRolesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, userhasroles.EdgeUsers)
	}
	if m.clearedroles {
		edges = append(edges, userhasroles.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserHasRolesMutation) EdgeCleared(name string) bool {
	switch name {
	case userhasroles.EdgeUsers:
		return m.clearedusers
	case userhasroles.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserHasRolesMutation) ClearEdge(name string) error {
	switch name {
	case userhasroles.EdgeUsers:
		m.ClearUsers()
		return nil
	case userhasroles.EdgeRoles:
		m.ClearRoles()
		return nil
	}
	return fmt.Errorf("unknown UserHasRoles unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserHasRolesMutation) ResetEdge(name string) error {
	switch name {
	case userhasroles.EdgeUsers:
		m.ResetUsers()
		return nil
	case userhasroles.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown UserHasRoles edge %s", name)
}
